---
title: Capabilities
---

Tauri provides application and plugin developers with a capabilities system,
to granually enable and constrain the core exposure to the application frontend running in the
system WebView.

Capabilities are a set of [permissions](/concepts/security/permissions) mapped
to application windows by window label.
Capabilities can contain multiple windows and multiple windows can
be part of multiple capabilities.

:::caution

Windows which are part of more than one capability
effectivly merge the security boundaries and permissions of all
involved capabilities.

:::

Permissions can define the [scope](/concepts/security/scope) of commands, which is used for granular access controls.

This can be configured in the `capabilities` section of the Tauri [configuration](/references/configuration-files#tauri-config).
For a full reference of the configuration scheme please see the [references](/references/v2/config) section.

```json
"capabilities":[
    {
        "identifier": "my-capability",
        "description": "my capability used for all windows",
        "context": "local",
        "windows": [ "*" ],
        "permissions": [
            "my-permission"
           ]
    }
]
```

For a more verbose configuration please see the [Examples](#examples) below.

## Security Boundaries

*What does it protect against?*

Depending on the permissions and capabilities it is able to:

- Minimize impact of frontend compromise
- Prevent or reduce (accidential) exposure of local system interfaces and data
- Prevent or reduce possible privilege escalation from frontend to backend/system

*What does it **not** protect against?*

- Malicious or insecure Rust code
- Too lax scopes and configuration
- Incorrect scope checks in the command implementation
- Intentional bypasses from Rust code
- Basically anything which was written in the rust core of an application
- 0-days or unpatched 1-days in the system WebView
- Supply chain attacks or otherwise compromised developer systems

:::caution

The security boundaries are depending on window labels (__not titles__).
We recommend to only expose of the window creation functionality
to higher privileged windows.

:::

## Configuration Files


Simplified example of an example Tauri application directory structure:

```sh
tauri-app
├── index.html
├── package.json
├── src
├── src-tauri
│   ├── Cargo.toml
│   ├── acl //optional
│      └── permissions
│         └── <identifier>.json/toml
│      └── capabilities
│         └── <identifier>.json/toml
│      └── permissions.json/toml
│      └── capabilities.json/toml
│   ├── src
│   ├── tauri.conf.json
```
Everything can be inlined into the `tauri.conf.json` but even a
little more advanced configuration would bloat this file and
the goal of this approach is that the permissions are abstracted
away whenever possible and simple to understand.

All permissions can be optionally described in the `acl/permissions.json` and
all capabilities in `acl/capabilities.json` or optionally even more
granular in individual files in the `acl/permissions` or `acl/capabilities` subfolder.

Only references or definitions enabled in the `tauri.conf.json` are actually
used in the application build.

## Examples

These snippets are part of the
[Tauri configuration](/references/configuration-files#tauri-config) file.

This is likely the most common configuration method,
where the individual capabilities are inlined and only
permissions are referenced by identifier.

```json
"capabilities":[
    {
        // Identifer which needs to be unique
        "identifier": "my-capability",
        // Description of the capability
        "description": "The default application capability used for all windows",
        // Context where the windows are used.
        // Can be used for dangerous remote origins to allow
        // remote hosted websites to facilitate the commands.
        "context": "local",
        // The `*` matches all windows
        "windows": [ "*" ],
        // List of permissions attached to this capability
        // The `fs:` namespace indicates the used permission
        // is provided from the filesystem plugin.
        "permissions": [
            "fs:default",
            "allow-home-read-extended"
           ]
    },
]
```

This simplified configuration requires well defined
capability files in the `acl/capabilities` directory
or in the `acl/capabilities.json`.

```json
"capabilities":[ "my-capability", "my-second-capability"]
```

Inline capabilities can be mixed with pre-defined capabilities.

