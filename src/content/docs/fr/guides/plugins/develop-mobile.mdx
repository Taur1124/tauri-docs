---
title: Développement de plugin mobile
i18nReady: true
---

:::tip[Développment de plugin]

Assurez-vous de bien connaître les concepts abordés dans le [Guide de développement de plugins](/fr/guide/plugins) car de nombreuses notions de ce guide reposent sur les concepts qui y sont couverts.

:::

Les plugins peuvent exécuter du code mobile natif écrit en Kotlin (ou Java) et Swift. Le modèle de plugin par défaut inclus un projet de librairie Android utilisant Kotlin, ainsi qu'un package Swift comprenant un exemple de commande mobile montrant comment déclencher son exécution à partir du code Rust.

## Initialiser le projet de plugin

Suivez les étapes dans le [Guide de développment de plugin](/fr/guide/plugins#initialiser-un-projet-de-plugin) pour initialiser un nouveau plugin.

Si vous avez un plugin existant et souhaitez y ajouter des fonctionnalités Android ou iOS, vous pouvez utiliser `plugin android add` et `plugin ios add` pour démarrer les projets de librairies mobiles et vous guider durant les changements nécessaires.

Le modèle de plugin par défaut sépare l'implémentation du plugin en deux modules séparés : `desktop.rs` et `mobile.rs`.

L'implémentation pour ordinateur utilise le code Rust pour implémenter une fonctionnalité, tandis que l'implémentation mobile envoie un message au code mobile natif pour exécuter une fonction et obtenir un résultat en retour. Si une logique partagée est entre les deux implémentations, elle peut être définie dans `lib.rs` :

```rust
// lib.rs
use tauri::Runtime;

impl<R: Runtime> <nom-du-plugin><R> {
  pub fn do_something(&self) {
    // faire une implémentation partagée entre l'ordinateur et le mobile
  }
}
```

Cette implémentation simplifie le processus de partage d'API, qui peut être utilisée à la fois par les commandes et par le code Rust.

### Développer un plugin Android

Un plugin Tauri pour Android est défini comme une classe Kotlin qui étend `app.tauri.plugin.Plugin` et est annotée avec `app.tauri.annotation.TauriPlugin`. Chaque méthode annotée avec `app.tauri.annotation.Command` peut être appelée par Rust ou JavaScript.

Tauri utilise Kotlin par défaut pour l'implémentation de plugins Android, mais vous pouvez passer à Java si vous préférez. Après avoir généré un plugin, faites un clique droit sur la classe (Kotlin) plugin dans Android Studio, puis sélectionnez l'option "Convert Kotlin file to Java file" {/* Seems like Android Studio is english only (on 14/09/2023) */} à partir du menu d'options. Android sutdio va vous guider tout au long de la migration vers Java.

### Développer un plugin iOS

Un plugin Tauri pour iOS est défini comme une classe Swift qui étend la classe `Plugin` du package `Tauri`. Chaque fonction avec l'attribut `@objc` et le paramètre `(_ invoke: Invoke)` (par exemple `@objc private func download(_ invoke: Invoke) { }`) peut être appelé par Rust ou JavaScript.

Le plugin est défini comme un [package Swift](https://www.swift.org/package-manager/), vous pouvez donc utiliser son gestionnaire de package pour gérer les dépendances.

## Configuration de plugins

Référez-vous à la section de [configuration de plugin](/fr/guide/plugins#configuration-de-plugin) du guide de développement de plugins pour plus de détails à propos du développement de configurations de plugin.

L'instance du plugin sur mobile possède un "getter" pour la configuration du plugin :

<Tabs>
<TabItem label="Android">

```java
@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
  override fun load(webView: WebView) {
    val timeout = this.config.getInt("timeout", 30)
  }
}
```

</TabItem>
<TabItem label="iOS">

```swift
class ExamplePlugin: Plugin {
  @objc public override func load(webview: WKWebView) {
    let timeout = self.config["timeout"] as? Int ?? 30
  }
}
```

</TabItem>
</Tabs>

## Évènement du cycle de vie.

Les plugins peuvent se lier à plusieurs évènements du cycle de vie :

- [load](#load): Lorsque le plugin est chargé dans la "web view"
- [onNewIntent](#onnewintent): Seulement pour Android, lorsque l'activitée est relancée

Il y a également les [évènements de cycle de vie supplémentaires pour les plugins](/fr/guide/plugins#évènements-du-cycle-de-vie) dans le guide de développement de plugins.

### load

- **Quand** : Lorsque le plugin est chargé dans la "web view"
- **Pourquoi** : Exécute le code d'initialisation du plugin

<Tabs>
<TabItem label="Android">

```java
@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
  override fun load(webView: WebView) {
    // effectuer l'installation du plugin ici
  }
}
```

</TabItem>
<TabItem label="iOS">

```swift
class ExamplePlugin: Plugin {
  @objc public override func load(webview: WKWebView) {
    let timeout = self.config["timeout"] as? Int ?? 30
  }
}
```

</TabItem>
</Tabs>

### onNewIntent

**Note** : Ceci est seulement disponible pour Android.

- **Quand** : Lorsque l'activité est relancée. Voir [Activité#onNewIntent](<https://developer.android.com/reference/android/app/Activity#onNewIntent(android.content.Intent)>) pour plus d'informations.
- **Pourquoi** : Gérer le redémarrage de l'application, par exemple lors du click sur une notification ou à l'accès d'un lien profond.

```java
// import android.content.Intent

@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
  override fun onNewIntent(intent: Intent) {
    // gérer le nouvel évènement d'attention
  }
}
```

## Ajouter des commandes mobiles

Une classe de plugin se trouve dans les projets mobiles respectifs, où les commandes peuvent être définies et peuvent être appelées par le code Rust :

import { Tabs, TabItem } from '@astrojs/starlight/components';

<Tabs>
<TabItem label="Android">

```java
@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
  @Command
  fun openCamera(invoke: Invoke) {
    val allowEdit = invoke.getBoolean("allowEdit", false)
    val quality = invoke.getInt("quality", 100)

    val ret = JSObject()
    ret.put("path", "/chemin/vers/photo.jpg")
    invoke.resolve(ret)
  }
}
```

</TabItem>
<TabItem label="iOS">

```swift
class ExamplePlugin: Plugin {
	@objc public func openCamera(_ invoke: Invoke) {
    let allowEdit = invoke.getBool("allowEdit", false)
    let quality = invoke.getInt("quality", 100)

    invoke.resolve(["path": "/chemin/vers/photo.jpg"])
	}
}
```

</TabItem>
</Tabs>

Utilisez [`tauri::plugin::PluginHandle`](https://docs.rs/tauri/2.0.0-alpha/tauri/plugin/struct.PluginHandle.html) pour appeler une commande mobile à partir de Rust :

```rust
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use tauri::Runtime;

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CameraRequest {
  quality: usize,
  allow_edit: bool,
}

#[derive(Deserialize)]
pub struct Photo {
  path: PathBuf,
}


impl<R: Runtime> <nom-du-plugin;pascal-case><R> {
  pub fn open_camera(&self, payload: CameraRequest) -> crate::Result<Photo> {
    self
      .0
      .run_mobile_plugin("openCamera", payload)
      .map_err(Into::into)
  }
}
```

## Permissions

Si un plugin requiert des permissions de l'utilisateur, Tauri simplifie le processus de vérification et de demande d'autorisation.

<Tabs>
<TabItem label="Android">

Premièrement, définissez la liste des permissions nécessaires et un alias pour identifier chaque groupe dans le code. Ceci est réalisé dans l'annotation `TauriPlugin` :

```java
@TauriPlugin(
  permissions = [
    Permission(strings = [Manifest.permission.POST_NOTIFICATIONS], alias = "postNotification")
  ]
)
class ExamplePlugin(private val activity: Activity): Plugin(activity) { }
```

</TabItem>
<TabItem label="iOS">

D'abord, il faut override les fonctions `checkPermissions` et `requestPermissions` :

```swift
class ExamplePlugin: Plugin {
  @objc open func checkPermissions(_ invoke: Invoke) {
    invoke.resolve(["postNotification": "prompt"])
  }

  @objc public override func requestPermissions(_ invoke: Invoke) {
    // demander les permissions ici
    // ensuite, puis résolvez la requête
    invoke.resolve(["postNotification": "granted"])
  }
}
```

</TabItem>
</Tabs>

Tauri implémente automatiquement deux commandes pour le plugin : `checkPermissions` et `requestPermissions`. Ces commandes peuvent être appelées directement depuis JavaScript ou Rust :

{/* TODO: PermissionState type should be exported in Tauri */}

<Tabs>
<TabItem label="JavaScript">

```javascript
import { invoke } from '@tauri-apps/api/tauri'

type PermissionState = 'granted' | 'denied' | 'prompt' | 'prompt-with-rationale'

interface Permissions {
  postNotification: PermissionState
}

// vérifier l'état de la permission
const permission = await invoke<Permissions>('plugin:<nom-du-plugin>|checkPermissions')

if (permission.postNotification === 'prompt-with-rationale') {
  // afficher les informations à l'utilisateur pour lesquelles cette permission est nécessaire
}

// demander la permission
if (permission.postNotification.startsWith('prompt')) {
  const state = await invoke<Permissions>('plugin:<nom-du-plugin>|requestPermissions', { permissions: ['postNotification'] })
}
```

</TabItem>
<TabItem label="Rust">

```rust
use serde::{Serialize, Deserialize};
use tauri::Runtime;

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct PermissionResponse {
  pub post_notification: PermissionState,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct RequestPermission {
  post_notification: bool,
}

impl<R: Runtime> Notification<R> {
  pub fn request_post_notification_permission(&self) -> crate::Result<PermissionState> {
    self.0
      .run_mobile_plugin::<PermissionResponse>("requestPermissions", RequestPermission { post_notification: true })
      .map(|r| r.post_notification)
      .map_err(Into::into)
  }

  pub fn check_permissions(&self) -> crate::Result<PermissionResponse> {
    self.0
      .run_mobile_plugin::<PermissionResponse>("checkPermissions", ())
      .map_err(Into::into)
  }
}
```

</TabItem>
</Tabs>

## Évènements liés aux plugins

{/* TODO: Is this section a duplicate of Lifecycle Events above? */}

Les plugins peuvent émettre (emit) à tout moment en utilisant la fonction `trigger` :

<Tabs>
<TabItem label="Android">

```java
@TauriPlugin
class ExamplePlugin(private val activity: Activity): Plugin(activity) {
    override fun load(webView: WebView) {
      trigger("load", JSObject())
    }

    override fun onNewIntent(intent: Intent) {
      // gérer le nouvel évènement d'attention
      if (intent.action == Intent.ACTION_VIEW) {
        val data = intent.data.toString()
        val event = JSObject()
        event.put("data", data)
        trigger("newIntent", event)
      }
    }

    @Command
    fun openCamera(invoke: Invoke) {
      val payload = JSObject()
      payload.put("open", true)
      trigger("camera", payload)
    }
}
```

</TabItem>
<TabItem label="iOS">

```swift
class ExamplePlugin: Plugin {
  @objc public override func load(webview: WKWebView) {
    trigger("load", data: [:])
  }

  @objc public func openCamera(_ invoke: Invoke) {
    trigger("camera", data: ["open": true])
  }
}
```

</TabItem>
</Tabs>

Les fonctions d'aide peuvent ensuite être appelées à partir du package NPM en utilisant la fonction d'aide [`addPluginListener`](/fr/reference/js/core/namespacetauri/#addpluginlistener) :

```javascript
import { addPluginListener, PluginListener } from '@tauri-apps/api/tauri';

export async function onRequest(
	handler: (url: string) => void
): Promise<PluginListener> {
	return await addPluginListener(
		'<nom-du-plugin>',
		'nom-du-plugin',
		handler
	);
}
```