---
title: Plugins
---

import CommandTabs from '@components/CommandTabs.astro';

{/* TODO: Link to windowing system, commands for sending messages, and event system */}

Tauri offers a windowing system with web view functionality, a way to send messages between the Rust process and the web view, and an event system along with several tooling to enhance the development experience. By design, the Tauri core does not contain features not needed by everyone. Instead it offers a mechanism to add external functionalities into a Tauri application called plugins. Plugins are able to hook into the Tauri lifecycle, expose Rust code that relies on the web view APIs, handle commands with Rust, Kotlin or Swift code, and much more.

## Available Plugins

The official Tauri plugins can be found on the [features and recipes page](/2/guide/list/). Recipes explaining how to combine plugins for common use cases as well as community plugins can also be found on that page.

## Add Plugin to Project

To add a plugin to a Tauri app, you can use the [`plugin add`](/2/reference/cli/#plugin-add) command.
For example, to install the [notification plugin](/2/guide/notification) run:

{/* TODO: `plugin add` is going to be renamed to `add` */}

<CommandTabs
	npm="npm run tauri plugin add notification"
	yarn="yarn tauri plugin add notification"
	pnpm="pnpm tauri plugin add notification"
	cargo="cargo tauri plugin add notification"
/>

Be sure to read the plugin's documentation to understand if any additional setup is required.

## Develop a Plugin

A Tauri plugin is composed of a Cargo crate and an optional NPM package that provides API bindings for its commands and events.
Additionally, a plugin project includes an Android library project and a Swift package for iOS, but you can delete those if your plugin does not target mobile.

{/* TODO: https://github.com/tauri-apps/tauri/issues/7749 */}

### Naming Convention

{/* TODO: Add link to allowlist */}

Tauri plugins have a `tauri-plugin-` prefix for the Rust crate name and a `@tauri-apps/plugin-` prefix for the NPM package. What comes after the prefix is the plugin name (specified on the plugin configuration under [`tauri.conf.json > plugin`](/2/reference/config/#pluginconfig) and on the allowlist configuration).

By default Tauri prefixes your plugin crate with `tauri-plugin-`. This helps your plugin to be discovered by the Tauri community, but is not not a requirement. When initializing a new plugin project, you must provide its name. The generated crate name will be `tauri-plugin-{plugin-name}` and the JavaScript NPM package name will be `tauri-plugin-{plugin-name}-api`, although we recommend using an NPM scope if possible. The Tauri naming convention for NPM packages is `@your-scope/plugin-{plugin-name}`.

### Initialize Plugin Project

To bootstrap a new plugin project, run [`plugin init`](/2/reference/cli/#plugin-init) command. If you do not need the NPM package, use the `--no-api` CLI flag.

<CommandTabs
	npm="npm run tauri plugin init"
	yarn="yarn tauri plugin init"
	pnpm="pnpm tauri plugin init"
	cargo="cargo tauri plugin init"
/>

This will initialize the plugin and the resulting code will look like this:

```
. plugin-name/
├── src/                - Rust code
│ ├── commands.rs       - defines the commands the webview can use
| ├── desktop.rs        - desktop implementation
│ ├── lib.rs            - re-exports appropriate implementation, setup state...
│ └── mobile.rs         - mobile implementation
├── android             - Android library
├── ios                 - Swift package
├── webview-src         - source code of the JavaScript API bindings
├── webview-dist        - Transpiled assets from webview-src
├── Cargo.toml          - Cargo crate metadata
└── package.json        - NPM package metadata
```

### Plugin Configuration

Plugins can read a configuration object from the Tauri configuration in the `plugins > {plugin-name}` object. The configuration is parsed at runtime:

```rust
// on the lib.rs file:

use tauri::plugin::{Builder, Runtime, TauriPlugin};
use serde::Deserialize;

// Define the plugin config
#[derive(Deserialize)]
struct Config {
  timeout: usize,
}

pub fn init<R: Runtime>() -> TauriPlugin<R> {
  // You can make the plugin config optional
  // by using `Builder::<R, Option<Config>>` instead
  Builder::<R, Config>::new("<plugin-name>")
    .setup(|app, api| {
      let timeout = api.config.timeout;
      Ok(())
    })
    .build()
}
```

In the Tauri application where the plugin is used, the configuration is set on `tauri.conf.json`:

```json
{
  "build": { ... },
  "tauri": { ... },
  "plugins": {
    "plugin-name": {
      "timeout": 30
    }
  }
}
```

Where `plugin-name` is your actual plugin name.

### Lifecycle Events

Plugins can hook into several lifecycle events:

- [setup](#setup): Plugin is being initialized
- [on_navigation](#on_navigation): Webview is attempting to perform a navigation
- [on_webview_ready](#on_webview_ready): New window is being created
- [on_event](#on_event): Event loop events
- [on_drop](#on_drop): Plugin deconstruction

#### setup

- **When**: Plugin is being initialized
- **Why**: Register mobile plugins, manage state, run background tasks

```rust
use tauri::{Manager, plugin::Builder};
use std::{collections::HashMap, sync::Mutex, time::Duration};

struct DummyStore(Mutex<HashMap<String, String>>);

Builder::new("<plugin-name>")
  .setup(|app, api| {
    app.manage(DummyStore(Default::default()));

    let app_ = app.clone();
    std::thread::spawn(move || {
      loop {
        app_.emit("tick", ());
        std::thread::sleep(Duration::from_secs(1));
      }
    });

    Ok(())
  })
```

#### on_navigation

- **When**: Webview is attempting to perform a navigation
- **Why**: Validate the navigation or track URL changes

Returning `false` cancels the navigation.

```rust
use tauri::plugin::Builder;

Builder::new("<plugin-name>")
  .on_navigation(|window, url| {
    println!("window {} is navigating to {}", window.label(), url);
    // Cancels the navigation if forbidden
    url.scheme() != "forbidden"
  })
```

#### on_webview_ready

- **When**: New window has been created
- **Why**: Execute an initialization script for every window

```rust
use tauri::plugin::Builder;

Builder::new("<plugin-name>")
  .on_webview_ready(|window| {
    window.listen("content-loaded", |event| {
      println!("webview content has been loaded");
    });
  })
```

#### on_event

- **When**: Event loop events
- **Why**: Handle core events such as window events, menu events and application exit requested (possibly denying the app to be exited to keep it on the tray for instance).

With this lifecycle hook you can be notified of any event loop [events](https://docs.rs/tauri/2.0.0-alpha/tauri/enum.RunEvent.html).

```rust
use std::{collections::HashMap, fs::write, sync::Mutex};
use tauri::{plugin::Builder, Manager, RunEvent};

struct DummyStore(Mutex<HashMap<String, String>>);

Builder::new("<plugin-name>")
  .setup(|app, _api| {
    app.manage(DummyStore(Default::default()));
    Ok(())
  })
  .on_event(|app, event| {
    match event {
      RunEvent::ExitRequested { api, .. } => {
        // user requested a window to be closed and there's no windows left

        // we can prevent the app from exiting:
        api.prevent_exit();
      }
      RunEvent::Exit => {
        // app is going to exit, you can cleanup here

        let store = app.state::<DummyStore>();
        write(
          app.path().app_local_data_dir().unwrap().join("store.json"),
          serde_json::to_string(&*store.0.lock().unwrap()).unwrap(),
        )
        .unwrap();
      }
      _ => {}
    }
  })
```

#### on_drop

- **When**: Plugin deconstruction
- **Why**: Execute code when the plugin has been destroyed

See [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) for more information.

```rust
use tauri::plugin::Builder;

Builder::new("<plugin-name>")
  .on_drop(|app| {
    // plugin has been destroyed...
  })
```

### Adding Commands

{/* TODO: Could this be linked to a more generic commands guide and only cover plugin-specific things here? */}
{/* What here is plugin-development specific vs. more general? */}

Commands are defined in the `commands.rs` file. They are regular Tauri applications commands. They can access the AppHandle and Window instances directly, access state, and take input the same way as application commands.

This command shows how to get access to the AppHandle and Window instance via dependency injection, and take two input parameters `on_progress` and `url`:

```rust
use tauri::{command, ipc::Channel, AppHandle, Runtime, Window};

#[command]
async fn upload<R: Runtime>(app: AppHandle<R>, window: Window<R>, on_progress: Channel, url: String) {
  // implement your command logic here
  on_progress.send(100).unwrap();
}
```

To actually expose the command to the webview, you must hook it on the `invoke_handler()` call on `lib.rs`:

```rust
Builder::new("<plugin-name>")
    .invoke_handler(tauri::generate_handler![commands::upload])
```

Now let's define a binding function on `webview-src/index.ts` so the plugin users can easily call that command:

```js
import { invoke, Channel } from '@tauri-apps/api/tauri'

export async function upload(url: string, onProgressHandler: (progress: number) => void): Promise<void> {
  const onProgress = new Channel<number>()
  onProgress.onmessage = onProgressHandler
  await invoke('plugin:<plugin-name>|upload', { url, onProgress })
}
```

Note that you must replace `<plugin-name>` with your actual plugin name so Tauri can reach your command.

When you are done implementing the command and want to test it out, don't forget to transpile the TypeScript code:

<CommandTabs
	npm="npm install
    npm run build"
	yarn="yarn install
    yarn build"
	pnpm="pnpm install
    pnpm build"
/>

## Managing State

{/* TODO: Link to a generic state management guide? */}

A plugin can manage state the same way a Tauri application does.

- Define a state struct and let Tauri manage it:

```rust
use std::{collections::HashMap, sync::Mutex};
use tauri::{Manager, plugin::Builder};

#[derive(Default)]
struct Store(Mutex<HashMap<usize, String>>);

Builder::new("<plugin-name>")
  .setup(|app, api| {
    app.manage(Store::default());

    // retrieve the store later
    let store = app.state::<Store>();
    Ok(())
  })
```
