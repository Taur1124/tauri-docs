<style is:global>
  hero-icon {
    display: block;
    width: 100%;
    height: 100%;
    background: transparent;
  }
  hero-icon canvas {
    background: transparent;
    width: 100%;
    height: 100%;
    opacity: 0;
    filter: blur(2px); /* Adjust as per your need */
    transition: all 2s ease-out;
  }
</style>

<script>
  interface Vertex {
    x: number;
    y: number;
    z: number;
  }

  class HeroIcon extends HTMLElement {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private angle: number = 0;
    private dragging: boolean = false;
    private lastX: number = 0;
    private lastY: number = 0;
    private angleX: number = 0;
    private momentum: number = 0;
    private centerX: number = 0;
    private centerY: number = 0;
    private centerZ: number = 0;
    private scale: number = 0;
    private obj: { vertices: Vertex[]; faces: number[][]; edges: Set<string> } = {
      vertices: [],
      faces: [],
      edges: [],
    };

    connectedCallback() {
      // Use `window` if you want the events to be captured outside of the canvas.
      // For `mousedown`, it might be better to keep it on the canvas if you only want
      // to initiate dragging from the canvas itself.
      this.addEventListener('mousedown', this.handleMouseDown);
      window.addEventListener('mousemove', this.handleMouseMove);
      window.addEventListener('mouseup', this.handleMouseUp);
    }

    disconnectedCallback() {
      this.removeEventListener('mousedown', this.handleMouseDown);
      window.removeEventListener('mousemove', this.handleMouseMove);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }

    private async loadObj() {
      try {
        const response = await fetch('/logo.obj');
        this.obj = this.parseOBJ(await response.text());
        this.draw();
        console.log(this.obj);
      } catch (e) {
        console.error('Error loading hero obj file: ', e);
      }
    }

    constructor() {
      super();

      this.loadObj();

      this.innerHTML = '<canvas />';
      this.canvas = this.querySelector('canvas')!;
      this.ctx = this.canvas.getContext('2d')!;

      this.canvas.width = 300;
      this.canvas.height = 300;

      // Mouse interaction event listeners
      this.handleMouseDown = this.handleMouseDown.bind(this);
      this.handleMouseMove = this.handleMouseMove.bind(this);
      this.handleMouseUp = this.handleMouseUp.bind(this);

      this.draw();

      const canvas = this.canvas;
      // After the canvas is appended, update its styles to trigger transitions
      setTimeout(() => {
        canvas.style.opacity = '1';
        canvas.style.filter = 'blur(0px)';
      }, 0);
    }

    private projectx(p: { x: number; y: number; z: number }) {
      return {
        x: p.x + this.canvas.width / 2,
        y: -p.y + this.canvas.height / 2,
      };
    }
    private project(p: { x: number; y: number; z: number }) {
      return {
        x: (p.x - this.centerX) * this.scale + this.canvas.width / 2,
        y: -(p.y - this.centerY) * this.scale + this.canvas.height / 2,
      };
    }

    private rotateY(p: { x: number; y: number; z: number }, angle: number) {
      return {
        x: p.x * Math.cos(angle) + p.z * Math.sin(angle),
        y: p.y,
        z: -p.x * Math.sin(angle) + p.z * Math.cos(angle),
      };
    }
    private rotateX(vertex: Vertex, angle: number): Vertex {
      const cosTheta = Math.cos(angle);
      const sinTheta = Math.sin(angle);

      return {
        x: vertex.x,
        y: vertex.y * cosTheta - vertex.z * sinTheta,
        z: vertex.y * sinTheta + vertex.z * cosTheta,
      };
    }

    private parseOBJ(data: string) {
      const vertices: Vertex[] = [];
      const faces: number[][] = [];
      const edges: Set<string> = new Set();
      let minX = Infinity,
        minY = Infinity,
        minZ = Infinity;
      let maxX = -Infinity,
        maxY = -Infinity,
        maxZ = -Infinity;

      const lines = data.split('\n');
      for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        if (parts[0] === 'v') {
          vertices.push({
            x: parseFloat(parts[1]),
            y: parseFloat(parts[2]),
            z: parseFloat(parts[3]),
          });
          minX = Math.min(minX, vertices[vertices.length - 1].x);
          minY = Math.min(minY, vertices[vertices.length - 1].y);
          minZ = Math.min(minZ, vertices[vertices.length - 1].z);
          maxX = Math.max(maxX, vertices[vertices.length - 1].x);
          maxY = Math.max(maxY, vertices[vertices.length - 1].y);
          maxZ = Math.max(maxZ, vertices[vertices.length - 1].z);
        } else if (parts[0] === 'f') {
          const face: number[] = [];
          for (let i = 1; i < parts.length; i++) {
            // Extract only the vertex index, considering complex formats
            const vertexIndex = parseInt(parts[i].split('/')[0]) - 1;
            face.push(vertexIndex);
          }
          faces.push(face);

          // Add edges from the face to the set
          for (let i = 0; i < face.length; i++) {
            const start = face[i];
            const end = face[(i + 1) % face.length];
            const edgeKey = start < end ? `${start},${end}` : `${end},${start}`;
            edges.add(edgeKey);
          }
        } else if (parts[0] === 'l') {
          // Directly extract edges from 'l' lines
          const start = parseInt(parts[1]) - 1;
          const end = parseInt(parts[2]) - 1;
          const edgeKey = start < end ? `${start},${end}` : `${end},${start}`;
          edges.add(edgeKey);
        }
      }

      // Convert edges from set to array
      const edgeArray = Array.from(edges).map((e) => e.split(',').map(Number));
      const scaleX = maxX - minX !== 0 ? this.canvas.width / (maxX - minX) : 1;
      const scaleY = maxY - minY !== 0 ? this.canvas.height / (maxY - minY) : 1;
      this.scale = Math.min(scaleX, scaleY) * 0.8; // 0.8 to leave some margin, adjust as needed
      this.centerX = (maxX + minX) / 2;
      this.centerY = (maxY + minY) / 2;
      this.centerZ = (maxZ + minZ) / 2;

      return { vertices, faces, edges: edgeArray };
    }

    private draw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Rotate the vertices based on current angles
      const rotatedVertices = this.obj.vertices.map((v) => {
        let tempVertex = this.rotateY(v, this.angle);
        return this.rotateX(tempVertex, this.angleX);
      });
      const projectedVertices = rotatedVertices.map((v) => this.project(v));

      // Draw edges
      this.ctx.strokeStyle = 'white'; // Or whatever color you desire for the glowing effect
      this.ctx.lineWidth = 2; // Adjust as needed
      for (const [startIdx, endIdx] of this.obj.edges) {
        const startVertex = projectedVertices[startIdx];
        const endVertex = projectedVertices[endIdx];
        this.ctx.beginPath();
        this.ctx.moveTo(startVertex.x, startVertex.y);
        this.ctx.lineTo(endVertex.x, endVertex.y);
        this.ctx.stroke();
      }

      // Use the loaded obj vertices and faces
      const loadedVertices = this.obj.vertices;
      const loadedFaces = this.obj.faces.map((face) => ({ vertices: face }));

      // Sort faces by average depth (similar to your pyramid)
      loadedFaces.sort((a, b) => {
        const zA =
          a.vertices.reduce((sum, idx) => sum + rotatedVertices[idx].z, 0) / a.vertices.length;
        const zB =
          b.vertices.reduce((sum, idx) => sum + rotatedVertices[idx].z, 0) / b.vertices.length;
        return zB - zA;
      });

      for (const face of loadedFaces) {
        // Using a generic color for illustration. You can adjust this
        // or even derive colors from other properties if needed.
        this.ctx.fillStyle = 'grey';
        this.ctx.beginPath();
        this.ctx.moveTo(
          projectedVertices[face.vertices[0]].x,
          projectedVertices[face.vertices[0]].y
        );
        for (let i = 1; i < face.vertices.length; i++) {
          this.ctx.lineTo(
            projectedVertices[face.vertices[i]].x,
            projectedVertices[face.vertices[i]].y
          );
        }
        this.ctx.closePath();
        this.ctx.fill();
      }

      // Rotate angle
      this.angle += 0.005;
      if (this.dragging) {
        this.angle += this.momentum;
      } else {
        this.momentum *= 0.97;
      }

      // Keep the angle between 0 and 2Ï€ for a continuous rotation
      this.angle %= 2 * Math.PI;

      if (!this.dragging) {
        // Gradually reset angleX to zero when not dragging
        this.angleX *= 0.95;
        if (Math.abs(this.angleX) < 0.01) {
          this.angleX = 0;
        }
      }

      requestAnimationFrame(() => this.draw());
    }

    private handleMouseDown(event: MouseEvent) {
      this.dragging = true;
      this.lastX = event.clientX;
      this.lastY = event.clientY; // Set initial Y position
      event.preventDefault();
    }

    private handleMouseMove(e: MouseEvent) {
      if (!this.dragging) return;

      const deltaX = e.clientX - this.lastX;
      const deltaY = e.clientY - this.lastY;

      this.lastX = e.clientX;
      this.lastY = e.clientY;

      this.momentum = deltaX * 0.005; // Adjust the factor for sensitivity

      // Apply a tilt on the X-axis based on vertical mouse movement
      this.angleX += deltaY * 0.005;
    }

    private handleMouseUp() {
      this.dragging = false;
    }
  }

  customElements.define('hero-icon', HeroIcon);
</script>
