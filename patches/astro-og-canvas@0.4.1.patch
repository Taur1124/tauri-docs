diff --git a/dist/generateOpenGraphImage.d.ts b/dist/generateOpenGraphImage.d.ts
index 50bbf6efaa3a1e5c387b7e7f73341a9dda3b7f9d..b5cffaf779cda698eace1a60f28524e4fe7a3df8 100644
--- a/dist/generateOpenGraphImage.d.ts
+++ b/dist/generateOpenGraphImage.d.ts
@@ -1,3 +1,3 @@
 /// <reference types="node" />
 import type { OGImageOptions } from './types';
-export declare function generateOpenGraphImage({ cacheDir, title, description, dir, bgGradient, bgImage, border: borderConfig, padding, logo, font: fontConfig, fonts, format, quality, }: OGImageOptions): Promise<Buffer>;
+export declare function generateOpenGraphImage({ cacheDir, title, description, extraField, dir, bgGradient, bgImage, border: borderConfig, padding, logo, font: fontConfig, fonts, format, quality, }: OGImageOptions): Promise<Buffer>;
diff --git a/dist/generateOpenGraphImage.js b/dist/generateOpenGraphImage.js
index 36cd8a807f04036afca7f83e660040255f4e7e1c..fb8f12cf572a80debecead92c6425b2876cca9d9 100644
--- a/dist/generateOpenGraphImage.js
+++ b/dist/generateOpenGraphImage.js
@@ -32,6 +32,14 @@ const defaults = {
             weight: 'Normal',
             families: ['Noto Sans'],
         },
+        extraField: {
+            color: [255, 255, 255],
+            size: 20,
+            lineHeight: 1,
+            weight: 'Normal',
+            families: ['Noto Sans'],
+        },
+
     },
 };
 class ImageCache {
@@ -58,7 +66,7 @@ class ImageCache {
     }
 }
 const imageCache = new ImageCache();
-export async function generateOpenGraphImage({ cacheDir = './node_modules/.astro-og-canvas', title, description = '', dir = 'ltr', bgGradient = [[0, 0, 0]], bgImage, border: borderConfig = {}, padding = 60, logo, font: fontConfig = {}, fonts = ['https://api.fontsource.org/v1/fonts/noto-sans/latin-400-normal.ttf'], format = 'PNG', quality = 90, }) {
+export async function generateOpenGraphImage({ cacheDir = './node_modules/.astro-og-canvas', title, description = '', extraField = '', dir = 'ltr', bgGradient = [[0, 0, 0]], bgImage, border: borderConfig = {}, padding = 60, logo, font: fontConfig = {}, fonts = ['https://api.fontsource.org/v1/fonts/noto-sans/latin-400-normal.ttf'], format = 'PNG', quality = 90, }) {
     // Load and configure font families.
     const fontMgr = await fontManager.get(fonts);
     const loadedLogo = logo && (await loadImage(logo.path));
@@ -91,6 +99,7 @@ export async function generateOpenGraphImage({ cacheDir = './node_modules/.astro
     const font = {
         title: { ...defaults.font.title, ...fontConfig.title },
         description: { ...defaults.font.description, ...fontConfig.description },
+        extraField: { ...defaults.font.extraField, ...fontConfig.extraField },
     };
     const isRtl = dir === 'rtl';
     const margin = {
@@ -182,10 +191,11 @@ export async function generateOpenGraphImage({ cacheDir = './node_modules/.astro
             // Matrix transform to scale the logo to the desired size.
             const imagePaint = new CanvasKit.Paint();
             imagePaint.setImageFilter(CanvasKit.ImageFilter.MakeMatrixTransform(CanvasKit.Matrix.scaled(xRatio, yRatio), { filter: CanvasKit.FilterMode.Linear }, null));
-            const imageLeft = isRtl
+            const imageLeft = !isRtl
                 ? (1 / xRatio) * (width - margin['inline-start']) - logoW
                 : (1 / xRatio) * margin['inline-start'];
-            canvas.drawImage(img, imageLeft, (1 / yRatio) * margin['block-start'], imagePaint);
+            const topPosition = height - (1 / yRatio) * margin['block-start'] - logoHeight;
+            canvas.drawImage(img, imageLeft, topPosition, imagePaint);
         }
     }
     if (fontMgr) {
@@ -203,6 +213,16 @@ export async function generateOpenGraphImage({ cacheDir = './node_modules/.astro
         // Add description.
         paragraphBuilder.pushStyle(new CanvasKit.TextStyle(textStyle(font.description)));
         paragraphBuilder.addText(decodeHTMLStrict(description));
+        // Add small empty line betwen description & extraField.
+        paragraphBuilder.pushStyle(
+            new CanvasKit.TextStyle({ fontSize: padding / 3, heightMultiplier: 1 })
+        );
+        paragraphBuilder.addText('\n\n');
+
+        // Add extraField
+        paragraphBuilder.pushStyle(new CanvasKit.TextStyle(textStyle(font.extraField)));
+        paragraphBuilder.addText(decodeHTMLStrict(extraField));
+
         // Draw paragraph to canvas.
         const para = paragraphBuilder.build();
         const paraWidth = width - margin['inline-start'] - margin['inline-end'] - padding;
@@ -210,8 +230,8 @@ export async function generateOpenGraphImage({ cacheDir = './node_modules/.astro
         const paraLeft = isRtl
             ? width - margin['inline-start'] - para.getMaxWidth()
             : margin['inline-start'];
-        const minTop = margin['block-start'] + logoHeight + (logoHeight ? padding : 0);
-        const maxTop = minTop + (logoHeight ? padding : 0);
+        const minTop = margin['block-start'];
+        const maxTop = minTop;
         const naturalTop = height - margin['block-end'] - para.getHeight();
         const paraTop = Math.max(minTop, Math.min(maxTop, naturalTop));
         canvas.drawParagraph(para, paraLeft, paraTop);
diff --git a/dist/types.d.ts b/dist/types.d.ts
index 78e6acd176efcb16524d674dcf210d7b51340222..6556aa61475f3f922fb6d9307ab521c20b488c87 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -36,6 +36,8 @@ export interface OGImageOptions {
     title: string;
     /** Short page description. */
     description?: string;
+    /** Optional extraField text. */
+    extraField?: string
     /** Writing direction. Default: `'ltr'`. Set to `'rtl'` for Arabic, Hebrew, etc. */
     dir?: 'rtl' | 'ltr';
     /** Optional site logo. Displayed at the top of the card. */
@@ -109,6 +111,8 @@ export interface OGImageOptions {
         title?: FontConfig;
         /** Font style for the page description. */
         description?: FontConfig;
+        /** Font style for the extraField. */
+        extraField?: FontConfig
     };
     /**
      * Array of font URLs or file paths to load and use when rendering text.
