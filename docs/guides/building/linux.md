---
sidebar_position: 4
---

import TauriBuild from './\_tauri-build.md'

# Linux Bundle

Tauri applications for Linux are distributed either with a Debian bundle (`.deb` file) or an AppImage (`.AppImage` file). The Tauri CLI automatically bundles your application code in these formats by default. Please note that `.deb` and `.AppImage` bundles can **only be created on Linux** as cross-compilation doesn't work yet.

:::note

GUI apps on macOS and Linux do not inherit the `$PATH` from your shell dotfiles (`.bashrc`, `.bash_profile`, `.zshrc`, etc). Check out Tauri's [fix-path-env-rs] crate to fix this issue.

:::

<TauriBuild />

## Limitations

Core libraries such as glibc frequently break compatibility with older systems. For this reason, you must build your Tauri application using the oldest base system you intend to support. A relatively old system such as Ubuntu 18.04 is more suited than Ubuntu 22.04, as the binary compiled on Ubuntu 22.04 will have a higher requirement of the glibc version, so when running on an older system, you will face a runtime error like `/usr/lib/libc.so.6: version 'GLIBC_2.33' not found`. We recommend using a Docker container or GitHub Actions to build your Tauri application for Linux.

See the issues [tauri-apps/tauri#1355] and [rust-lang/rust#57497], in addition to the [AppImage guide] for more information.

## Debian

The stock Debian package generated by the Tauri bundler has everything you need to ship your application to Debian-based Linux distributions, defining your application's icons, generating a Desktop file, and specifying the dependencies `libwebkit2gtk-4.0-37` and `libgtk-3-0`, along with `libappindicator3-1` if your app uses the system tray.

### Custom Files

Tauri exposes a few configurations for the Debian package in case you need more control.

If your app depends on additional system dependencies you can specify them in `tauri.conf.json > tauri > bundle > deb > depends`.

To include custom files in the Debian package, you can provide a list of files or folders in `tauri.conf.json > tauri > bundle > deb > files`. The configuration object maps the path in the Debian package to the path to the file on your filesystem, relative to the `tauri.conf.json` file. Here's an example configuration:

```json
{
  "tauri": {
    "bundle": {
      "deb": {
        "files": {
          "/usr/share/README.md": "../README.md", // copies the README.md file to /usr/share/README.md
          "usr/share/assets": "../assets/" // copies the entire assets directory to /usr/share/assets
        }
      }
    }
  }
}
```

If you need to bundle files in a cross-platform way, check Tauri's [resource] and [sidecar] mechanisms.

## AppImage

AppImage is a distribution format that does not rely on the system installed packages and instead bundles all dependencies and files needed by the application. For this reason, the output file is larger but easier to distribute since it is supported on many Linux distributions and can be executed without installation. The user just needs to make the file executable (`chmod a+x MyProject.AppImage`) and can then run it (`./MyProject.AppImage`).

AppImages are convenient, simplifying the distribution process if you cannot make a package targeting the distribution's package manager. Still, you should carefully use it as the file size grows from the 2-6MBs range to 70+MBs.

:::caution

If your app plays audio/video you need to enable `tauri.conf.json > tauri > bundle > appimage > bundleMediaFramework`. This will increase the size of the AppImage bundle to include additional `gstreamer` files needed for media playback. This flag is currently only supported on Ubuntu build systems.

:::

## Cross-Compiling Tauri Applications for ARM-based Devices

This guide explains how to cross-compile your Tauri application for ARM-based devices, such as the Raspberry Pi. Compiling directly on the device may not be feasible due to limited RAM, so we'll explore two methods: manual compilation using Linux or WSL on Windows and automatic cross-compilation using a GitHub Action.

### Manual Compilation

Manual compilation is suitable when you don't need to compile your application frequently and prefer a one-time setup. Follow the steps below:

#### Prerequisites

:::warning

Ubuntu 20.04 WSL has issues with webkit dependencies. It's recommended to use Debian instead.
Furthermore, AppImage is not supported on ARM devices. To avoid Tauri from building it, you need to customize tauri.conf.json in the src-tauri folder. Adjust the "targets" array to include only the desired platforms for your ARM-based device. For instance:

"targets": ["deb", "nsis", "msi", "app", "dmg", "updater"],

:::

- For Windows, install Debian on WSL using the [wsl setup guide].
- On Linux, the build machine requires GLIBC version equal to or older than the target device. Check using: `ldd --version`.
- Use a Linux distribution based on Debian/Ubuntu for this guide, as the commands shown use the `apt` package manager and have been tested on Debian 11.

#### Cross-Compiling

Now, let's cross-compile the Tauri application for ARM:

1. Install Rust targets for your desired architecture:
   - For ARMv7 (32-bit): `rustup target add armv7-unknown-linux-gnueabihf`
   - For ARMv8 (ARM64, 64-bit): `rustup target add aarch64-unknown-linux-gnu`

2. Install the corresponding linker for your chosen architecture:
   - For ARMv7: `sudo apt install gcc-arm-linux-gnueabihf`
   - For ARMv8 (ARM64): `sudo apt install gcc-aarch64-linux-gnu`

3. Open or create the file `<project-root>/.cargo/config.toml` and add the following configurations accordingly:
   ```toml
   [target.armv7-unknown-linux-gnueabihf]
   linker = "arm-linux-gnueabihf-gcc"
   
   [target.aarch64-unknown-linux-gnu]
   linker = "aarch64-linux-gnu-gcc"
   ```

4. Enable the respective architecture in the package manager (only for non-Debian distributions):
   - For ARMv7: `sudo dpkg --add-architecture armhf`
   - For ARMv8 (ARM64): `sudo dpkg --add-architecture arm64`

:::info Adjusting Package Sources

On Debian, this step isn't necessary, but on other distributions, you might need to edit `/etc/apt/sources.list` to include the ARM architecture variant. For example, add these lines:
```bash
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy main restricted
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy universe
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates universe
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy multiverse
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-updates multiverse
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-backports main restricted universe multiverse
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security universe
deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports jammy-security multiverse
```
After making changes, verify if the armhf architecture is still enabled in the package manager by re-running the command from Step 4.

:::

5. Update the package information: `sudo apt-get update && sudo apt-get upgrade -y`.

6. Install the required webkitgtk library for your chosen architecture:
   - For ARMv7: `sudo apt install libwebkit2gtk-4.0-dev:armhf`
   - For ARMv8 (ARM64): `sudo apt install libwebkit2gtk-4.0-dev:arm64`

7. Set the `PKG_CONFIG_SYSROOT_DIR` to the appropriate directory based on your chosen architecture:
   - For ARMv7: `export PKG_CONFIG_SYSROOT_DIR=/usr/arm-linux-gnueabihf/`
   - For ARMv8 (ARM64): `export PKG_CONFIG_SYSROOT_DIR=/usr/aarch64-linux-gnu/`

8. Build the app for your desired ARM version:
   - For ARMv7: `cargo tauri build --target armv7-unknown-linux-gnueabihf`
   - For ARMv8 (ARM64): `cargo tauri build --target aarch64-unknown-linux-gnu`

Choose the appropriate set of instructions based on whether you want to cross-compile your Tauri application for ARMv7 or ARMv8 (ARM64). Please note that the specific steps may vary depending on your Linux distribution and setup.

### Experimental: Automatic Cross-Compilation using a GitHub Action

For automated ARM executable builds on GitHub, we'll use the [arm-runner-action] created by [Paul Guyot].

:::warning

AppImage is not supported on ARM devices. To avoid Tauri building it, you need to customize `tauri.conf.json` in the `src-tauri` folder. Adjust the `"targets"` array to include only the desired platforms for your ARM-based device. For instance:
```json
"targets": ["deb", "nsis", "msi", "app", "dmg", "updater"],
```

:::

#### Setup

Follow the instructions in the [arm-runner-action repository] README to set up the GitHub Action. If you're new to GitHub Actions, read the [GitHub Actions guide] first.

Customize the last step in the GitHub Action YAML to generate a `.deb` file instead of an `.img` file:

```yaml
name: Raspberry Pi compile
on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pguyot/arm-runner-action@v2.5.2
        with:
          base_image: https://dietpi.com/downloads/images/DietPi_RPi-ARMv8-Bullseye.7z
          cpu: cortex-a53
          bind_mount_repository: true
          image_additional_mb: 10240
          optimize_image: false
          commands: |
            # Rust complains (rightly) that $HOME doesn't match eid home
            export HOME=/root
            # Workaround to CI worker being stuck on Updating crates.io index
            export CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse
            # Install setup prerequisites
            apt-get update -y --allow-releaseinfo-change
            apt-get upgrade -y
            apt-get autoremove -y
            apt-get install curl
            curl https://sh.rustup.rs -sSf | sh -s -- -y
            . "$HOME/.cargo/env"
            curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash
            # Install framework specific packages
            apt-get install -y nodejs
            npm install next@latest react@latest react-dom@latest eslint-config-next@latest
            # Install build tools and tauri-cli requirements
            apt-get install -y libwebkit2gtk-4.0-dev build-essential wget libssl-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev
            cargo install tauri-cli
            # Install frontend dependencies
            npm install
            # Build the application
            cargo tauri build
      - name: Upload deb bundle
        uses: actions/upload-artifact@v3
        with:
          name: Debian Bundle
          path: ${{ github.workspace }}/target/release/bundle/deb/tauri_1.4_arm64.deb
```

Adjust the `path` variable to match your application's version and name:
`${{ github.workspace }}/target/release/bundle/deb/[name]_[version]_arm64.deb`.

[resource]: resources.md
[sidecar]: sidecar.md
[debian package]: https://wiki.debian.org/Packaging
[appimage]: https://appimage.org/
[tauri-apps/tauri#1355]: https://github.com/tauri-apps/tauri/issues/1355
[rust-lang/rust#57497]: https://github.com/rust-lang/rust/issues/57497
[appimage guide]: https://docs.appimage.org/reference/best-practices.html#binaries-compiled-on-old-enough-base-system
[fix-path-env-rs]: https://github.com/tauri-apps/fix-path-env-rs

[wsl setup guide]: https://www.linuxfordevices.com/tutorials/linux/install-debian-on-windows-wsl
[system requirements]: https://tauri.app/v1/guides/getting-started/prerequisites#setting-up-linux
[Tauri using Cargo]: https://tauri.app/v1/guides/getting-started/setup/next-js/#create-the-rust-project
[arm-runner-action]: https://github.com/pguyot/arm-runner-action
[arm-runner-action repository]: https://github.com/pguyot/arm-runner-action
[Paul Guyot]: https://github.com/pguyot
[GitHub Actions guide]: https://docs.github.com/en/actions
