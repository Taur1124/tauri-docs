---
description: Build a Tauri app using NextJS as the frontend build tool
pagination_next: guides/architecture/README
sidebar_custom_props:
  doc_card_image: /img/guides/getting-started/setup/vite.svg
---

import TauriInit from './_fragments/_tauri-init.mdx'
import Commands from './_fragments/_commands.mdx'
import Intro from './_fragments/_intro.mdx'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Command from '@theme/Command'

# NextJS

This guide will walk you through creating your first Tauri app using the React framework [nextjs].

<Intro />

Here's a preview of what we will be building:

![Application Preview](./next-light.png#gh-light-mode-only)
![Application Preview](./next-dark.png#gh-dark-mode-only)

## Create the Frontend

[NextJS] is a React Framework that came with both `SSR` and `SSG` capability to make it work with tauri we are only going to use `SSG` mode.
It comes with a scaffolding utility similar to `create-tauri-app` that can quickly setup a new project from a number of pre-defined templates.
For this guide we will use the `typescript` template to create a simple project.

<Tabs groupId="package-manager">
  <TabItem value="npm" label="npm" default>

```shell
npx create-next-app@latest --use-npm --typescript
```

  </TabItem>
  <TabItem value="yarn" label="yarn">

```shell
yarn create next-app --typescript
```

  </TabItem>
  <TabItem value="pnpm" label="pnpm">

```shell
pnpm create next-app --use-pnpm --typescript
```

  </TabItem>
</Tabs>

1. **Project name**  
   This will be the name of your JavaScript project. Corresponds to the name of the folder this utility will create but has otherwise no effect on your app. You can use any name you want here.

When starting the frontend via the `next-app` command, Next will look for a config file named `next.config.js` inside the project root.
We want to customize this file to get the best compatibility with Tauri.

Update the file with the following content: 

```typescript title=next.config.js
/** @type {import('next').NextConfig} */

const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  // Note: This experimental feature is require to use NextJS Image in SSG mode
  // You can see other workarround https://nextjs.org/docs/messages/export-image-api
  experimental: {
    images: {
      unoptimized: true,
    },
  },
}

module.exports = nextConfig;
```

To be abble to build in production we must add `next export` command in `package.json`.
This will render a pure Html/JavaScript version of your [NextJS] application and create the `out` folder.
We are also going to add `tauri` command.

You `package.json` should look like this:

```json title=package.json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "export": "next export",
    "start": "next start",
    "tauri": "tauri",
    "lint": "next lint"
  },
```

## Create the Rust Project

<TauriInit destDirValue="../out" devPathValue="http://localhost:3000" />

Now that we have scaffolded our Frontend and initialized the Rust project you're almost ready to run your App.
But before you do, let's quickly configure Tauri so it **automatically** start's the next development server when you type `tauri dev` and automatically runs the build and export script when you run `tauri build`:

```json title=src-tauri/tauri.conf.json
{
  "build": {
    // highlight-start
    // this command will execute when you run `tauri build`
    "beforeBuildCommand": "npm run build && npm run export",
    // this command will execute when you run `tauri dev`
    "beforeDevCommand": "npm run dev",
    // highlight-end
    "devPath": "http://localhost:3000",
    "distDir": "../out"
  },
```

And that's it! Now you can run the following command in your terminal to start a development build of your app:

<Command name="dev" />

![Application Window](./next-dev-light.png#gh-light-mode-only)
![Application Window](./next-dev-dark.png#gh-dark-mode-only)

## Invoke Commands

<Commands />

To call our newly created command we will use the [`@tauri-apps/api`] JavaScript library. It provides access to core functionality such as windows, the filesystem, and more through convenient JavaScript abstractions. You can install it using your favorite JavaScript package manager:

<Tabs groupId="package-manager">
  <TabItem value="npm" label="npm" default>

```shell
npm install @tauri-apps/api
```

  </TabItem>
  <TabItem value="yarn" label="yarn">

```shell
yarn add @tauri-apps/api
```

  </TabItem>
  <TabItem value="pnpm" label="pnpm">

```shell
pnpm add @tauri-apps/api
```

  </TabItem>
</Tabs>

With the library installed, you can modify your `pages/index.ts` file to call the Command:

```typescript title=pages/index.tsx
import { invoke } from "@tauri-apps/api/tauri"

// Note: When working with NextJS in development you have 2 execution contexts:
// - In server side where Tauri cannot be call because it's out of his context.
// - In client side where Tauri can be executed.
// To know if we are in server or client side we can do it like this:
const isClient = typeof window !== 'undefined'

// now we can call our Command!
// Right-click the application background and open the developer tools.
// You will see "Hello, World!" printed in the console!
isClient && invoke('greet', { name: 'World' })
    .then(console.log)
    .catch(console.error)
```

A better approche will be to use tauri calls in `componentDidMount` or `useEffect` that are only run in client side by [NextJS]

:::tip

If you want to know more about the communication between Rust and JavaScript, please read the Tauri [Inter-Process Communication][inter-process-communication] guide.

:::

<!-- TODO: Show how you can add this and screenshots of what it looks like -->

[nextjs]: https://nextjs.org
[cargo]: https://doc.rust-lang.org/cargo/
[typescript]: https://www.typescriptlang.org
[prerequisites]: ../prerequisites.md
[`@tauri-apps/api`]: ../../../api/js/
[inter-process-communication]: ../../architecture/inter-process-communication/README.md
